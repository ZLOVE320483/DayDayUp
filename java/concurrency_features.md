## Java并发三大特性

### 并发编程三大特性——原子性、可见性、有序性

在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。

### 原子性

即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

```
i = 0;       //1
j = i ;      //2
i++;         //3
i = j + 1;   //4
```

上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。

> 1在Java中，对基本数据类型的变量和赋值操作都是原子性操作； 

> 2中包含了两个操作：读取i，将i值赋值给j 

> 3中包含了三个操作：读取i值、i + 1 、将+1结果赋值给i； 

> 4中同三一样

在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作，如long、double）。

要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。

### 可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

举个简单的例子，看下面这段代码：

```
//线程1执行的代码
int i = 0;
i = 10;

//线程2执行的代码
j = i;
```

假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。

对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

### 有序性

即程序执行的顺序按照代码的先后顺序执行。

举个简单的例子，看下面这段代码：

```
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句
```

上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。

下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：

```
int a = 10;    //语句1
int r = 2;    //语句2
a = a + 3;    //语句3
r = a*a;     //语句4
```

这段代码有4个语句，那么可能的一个执行顺序是：

语句2 -> 语句1 -> 语句3 -> 语句4

那么可不可能是这个执行顺序：

语句2 -> 语句1 -> 语句4 -> 语句3。

不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：

```
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
```

上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

### volatile、atomic、reentrantLock、synchronized区别

- JAVA的内存模块，JAVA的内存模块特点，原子性、可见性、有序性。例如：int i = 0，是原子性操作，i++非原子性操作；有序性是指同一个线程中，程序的前面代码必须执行完毕之后才会执行后面代码；可见性是指，CPU拥有缓存，一般都是从内存中读取数据到CPU缓存，然后经过多次计算和处理的中间结果放在CPU缓存中，最后把结果写回内存，可见性就是为了放弃CPU缓存，所有结果都在内存，对所有线程都可见。

- volatile，只能保证可见性，但是不能保证原子性，因为 new object(),一般会经过3个步骤，1、给对象分配内存，2、初始化构造函数，3、指针指向内存地址。因为现在CPU都是多CPU、多核，JVM为了提供性能，允许多条指令在不同CPU运行，因此可能是1 -2 -3 顺序，也可能是1-3 -2顺序。volatile就屏蔽编译指令重排，多用与并行计算的单例模式。另外，volatile制定了CPU每次都必须从内存读取数据，不能从CPU缓存中读取，因此就保证了多线程在多CPU计算中永远拿的都是最新的值。但是volatile无法实现原子性，例如i++;volatile不能让多线程同步计算。

- volatile只能实现可见性，无法实现原子性，而atomic关键字正好弥补了volatile的缺点。

- synchronized，保证了线程的同步进行。synchronized可以用于函数，也可以用于代码段，synchronized为非公平锁，通过锁实现了代码中的并行计算。

- reentrantLock，reentrantLock能够实现synchronized的所有功能，并且具有以下几个特点：
	1. reentrantLock对代码加锁的颗粒性会更小，更节省资源，提高代码性能。
	2. reentrantLock可以设置多个条件，满足这些条件的才能加锁或者释放锁。
	3. reentrantLock能实现公平锁和非公平锁，而synchronied是一个非公平锁。公平锁，就是先来的先获取资源，非公平锁就是每次都是相互争抢。
	4. reentrantLock可以进行中断，等待锁的机制。